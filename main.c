/*----------------------------------------------------------------------*/
/* Programa principal de acesso ao MMC com FAT-FS			*/
/* Baseado no programa							*/
/* FAT file system sample project for FatFs		(C)ChaN, 2009	*/
/* http://elm-chan.org/docs/mmc/mmc_e.html				*/
/* Adaptado por Marcos A. Stemmer para o kit LPC2478			*/
/* de Sistemas Embarcados 2010 da FENG-PUCRS				*/
/*----------------------------------------------------------------------*/

#include <string.h>
#include <math.h>
#include "LPC2300.h"
#include "integer.h"
#include "interrupt.h"
#include "uart.h"
#include "monitor.h"
#include "rtc.h"
#include "diskio.h"
#include "ff.h"
#include "lcd.h"
#include "i2c.h"
#include "adxl345.h"
#include "comandos.h"
#include "defines.h"
#include "mprintf.h"
#include "gps_decode.h"
#include "gps_structs.h"

DWORD acc_size;		/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO Finfo;
#if _USE_LFN
char Lfname[512];
#endif

char Line[120];			/* Console input buffer */
char Data[128];			/* GPS data buffer */

FATFS Fatfs[_VOLUMES];		/* File system object for each logical drive */

volatile UINT Timer;		/* Performance timer (1kHz increment) */

/*---------------------------------------------------------*/
/* 1000Hz timer interrupt generated by TIMER0              */
/*---------------------------------------------------------*/

void Isr_TIMER0 (void)
{
	T0IR = 1;		/* Clear irq flag */
	Timer++;
	disk_timerproc();	/* Disk timer process */
}

/*---------------------------------------------------------*/
/* User Provided RTC Function for FatFs module             */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support an RTC.                     */
/* This function is not required in read-only cfg.         */

DWORD get_fattime ()
{
	RTC rtc;
	/* Get local time */
	rtc_gettime(&rtc);
	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}

/* Configuracao inicial */
static void IoInit (void)
{
#define PLL_N		1UL
#define PLL_M		6UL
#define CCLK_DIV	2

if ( PLLSTAT & (1 << 25) ) {
	PLLCON = 1;	/* Disconnect PLL output if PLL is in use */
	PLLFEED = 0xAA; PLLFEED = 0x55;
}
PLLCON = 0;			/* Disable PLL */
PLLFEED = 0xAA; PLLFEED = 0x55;
/* Depois deste comando deve-se usar FIO1PIN para acessar a porta P1 */
SCS = 0x21;	/* Liga o oscilador externo (12MHz) e o GPIO */
while( !(SCS & 0x40) );	/* Espera estabilizar o oscilador */
CLKSRCSEL = 0x1;	/* Usa o 12MHz como oscilador principal */
//	CLKSRCSEL = 0;	// Antes pegava o oscilador interno de 4MHz

PLLCFG = ((PLL_N - 1) << 16) | (PLL_M - 1); // PLL em 144MHz
PLLFEED = 0xAA; PLLFEED = 0x55;
PLLCON = 1;	// Liga PLL desconectado
PLLFEED = 0xAA; PLLFEED = 0x55;

while ((PLLSTAT & (1 << 26)) == 0);	// Espera PLL lock
CCLKCFG = CCLK_DIV-1;	// SYSCLK = 72 MHz
PLLCON = 3;				/* Connect PLL output to the sysclk */
PLLFEED = 0xAA; PLLFEED = 0x55;

MAMCR = 0;				/* Configure MAM with 0 wait operation */
MAMTIM = 3;
MAMCR = 2;

PCLKSEL0 = 0x00000000;	/* PCLK = SYSCLK/4 (18MHz) */
PCLKSEL1 = 0x00000000;	/* em todos os perifericos */

rtc_initialize();	/* Initialize RTC */
ClearVector();		/* Initialie VIC */
SCS |= 1;		/* Enable FIO0 and FIO1 */
/* No kit da PUCRS tem um LED no pino P1.29 */
#if MODELO == 2009
FIO4DIR |= ALL_LED;		/* LED8|LED7|LED6|LED5|LED4|LED3|LED2|LED1 */
FIO4SET = ALL_LED;
#else
FIO4DIR |= 0x10;		/* - | - | - |LED5| - | - | - | - */
FIO4SET = 0x10;
#endif

/* Registra o vetor de interrupcao IRQ do timer0 no VIC */
RegisterVector(TIMER0_INT, Isr_TIMER0, PRI_LOWEST, CLASS_IRQ);
/* Timer T0 faz 18M contagens/segundo */
T0CTCR = 0;
T0MR0 = 18000 - 1;		/* 1000 Interrupt/sec */
T0MCR = 0x3;			/* Clear TC and Interrupt on MR0 match */
T0TCR = 1;

uart0_init();			/* Initialize UART0 */
uart1_init();

IrqEnable();			/* Enable Irq */

}

/* espera t milisegundos (usa timer T1) */
void espera_ms(unsigned t)
{
unsigned x;
while(t--){
	x = T0TC;
	while(x == T0TC);
	}
}

/* Interpreta uma linha de comando */
void comando(char *cml);

int accel_init(void)
{
	/* Testes I2C, acelerometro*/
	int i, x, y, z;
	int x_off = 0, y_off = 0, z_off = 0;
	FIO4CLR = LED7;
	while (BTO1) {};
	for(i=0;i<100;i++) {
		adxl345_get_xyz(&x, &y, &z);
		x_off += x;
		y_off += y;
		z_off += z;
	}
	adxl345_init(x_off/100, y_off/100, z_off/100);
	FIO4SET = LED7;
	return 0;
}

static void hardware_init(void)
{

	IoInit();
	ini_i2c();
	adxl345_init(0,0,0);
	LCDinit();
	memset(&GPS_TEXT, 0, sizeof(GPS_TEXT));
	accel_init();
}

static int sys_init(void)
{
	RTC rtc;

	xputs("********************************************************************************\n");
	xputs("*                                FENG PUC-RS                                   *\n");
	xputs("*                                                                              *\n");
	xputs("*                         VINICIUS GRUBEL KLEINUBING                           *\n");
	xputs("*                                                                              *\n");
	xputs("********************************************************************************\n");

	LCDputs("FENG TCC EC VGK");
	LCDp(L2, "Wait for GPS");
	xputs("Wait for GPS");
	/* Wait GPS, for sinc time */
	do {
		while (uart1_test() == 0) {};
		x1_get_line(Data, sizeof(Data));
	} while (parse_packet(Data) != 0);

	xputs(" - OK\n");

	/* GPS OK */
	FIO4CLR = LED2;
	rtc.year = (WORD)(GPS_TEXT.year+2000);
	rtc.month = (BYTE)GPS_TEXT.month;
	rtc.mday = (BYTE)GPS_TEXT.day;
	rtc.hour = (BYTE)(GPS_TEXT.hour);
	rtc.min = (BYTE)GPS_TEXT.min;
	rtc.sec = (BYTE)GPS_TEXT.sec;
	rtc_settime(&rtc);

	LCDp(L2, "Wait for SD CARD");
	xputs("Wait for SD Card");
	while(disk_initialize(0) != 0) {};
	while(f_mount(0, &Fatfs[0]) != FR_OK) {};
	FIO4CLR = LED1;
	xputs(" - Ok\n");

	LCDp(L2, "---- READY -----");
	xputs("----- READY -----");

	return 0;
}

static int sys_loop(void)
{
	FIL File;
	int res;
	char log_name[30];
	RTC rtc;
	int trackpoint = 0;
	int x_axis=0, amostras=0;

	/* Get local time */
	rtc_gettime(&rtc);
	xprintf("%u %u %u %02u:%02u:%02u\n", rtc.year, rtc.month,
			rtc.mday, rtc.hour, rtc.min, rtc.sec);

	sprintf(log_name, "gps_%02d%02d%02d_%02d%02d%02d.log", rtc.mday, rtc.month, rtc.year, rtc.hour, rtc.min, rtc.sec);

	/* Open file for read and write */
	res = f_open(&File, log_name, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
	if (res) { LCDp(L2, "ERROR - SD CARD"); return res; }
	res = f_sync(&File); 
	if (res) { LCDp(L2, "ERROR - SD CARD"); return res; }

	/* Write header data */
	f_printf(&File, "trackpoint,time,latitude,longitude,amostras,n,name\n");
	res = f_sync(&File);
	if (res) {LCDp(L2, "ERROR - SD CARD"); return res;}

	while (!BTO1) {
		if (uart1_test() == 0) {
			int dummy = adxl345_get_x();
			x_axis = x_axis + (dummy*dummy);
			amostras++;
			continue;
		}
		x1_get_line(Data, sizeof(Data));

		/* Media quadratica */
		x_axis = sqrt(x_axis/amostras);

		if (amostras == 0) {
			x_axis = 0;
			continue;
		}
		res = parse_packet(Data);
		if (res == 0) {
			/* GPS OK */
			FIO4CLR = LED2;
			if (trackpoint == 0){
				f_printf(&File, "%d,%02d:%02d:%02d,%02d %02d.%03d,%03d %02d.%3d,%d,%d,TRACK%0d%02d%02d%02d%02d%02d\n", trackpoint, 
						GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec, GPS_TEXT.lat_d, GPS_TEXT.lat_mm, GPS_TEXT.lat_mmm, GPS_TEXT.lon_d, GPS_TEXT.lon_mm, GPS_TEXT.lon_mmm, amostras, x_axis, GPS_TEXT.day, GPS_TEXT.month, GPS_TEXT.year, GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec);
				xprintf("%d,%02d:%02d:%02d,%02d %02d.%03d,%03d %02d.%3d,%d,%d,TRACK%0d%02d%02d%02d%02d%02d\n", trackpoint, 
						GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec, GPS_TEXT.lat_d, GPS_TEXT.lat_mm, GPS_TEXT.lat_mmm, GPS_TEXT.lon_d, GPS_TEXT.lon_mm, GPS_TEXT.lon_mmm, amostras, x_axis, GPS_TEXT.day, GPS_TEXT.month, GPS_TEXT.year, GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec);
			}
			else
			{
				f_printf(&File, "%d,%02d:%02d:%02d,%02d %02d.%03d,%03d %02d.%3d,%d,%d\n", trackpoint, 
						GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec, GPS_TEXT.lat_d, GPS_TEXT.lat_mm, GPS_TEXT.lat_mmm, GPS_TEXT.lon_d, GPS_TEXT.lon_mm, GPS_TEXT.lon_mmm, amostras, x_axis);
				xprintf("%d,%02d:%02d:%02d,%02d %02d.%03d,%03d %02d.%3d,%d,%d\n", trackpoint, 
						GPS_TEXT.hour, GPS_TEXT.min, GPS_TEXT.sec, GPS_TEXT.lat_d, GPS_TEXT.lat_mm, GPS_TEXT.lat_mmm, GPS_TEXT.lon_d, GPS_TEXT.lon_mm, GPS_TEXT.lon_mmm, amostras, x_axis);
			}
			trackpoint ++;
		}
		if (res == -1) {
			/* GPS FAIL */
			FIO4SET = LED2;

			/* Sincronize last data */
			res = f_sync(&File);
			if (res) {LCDp(L2, "ERROR - SD CARD"); return res;}

			LCDp(L2, "  Wait for GPS  ");
			/* Wait GPS, for sinc time */
			xprintf("Wait for GPS signal \n");
			do {
				while (uart1_test() == 0) {};
				x1_get_line(Data, sizeof(Data));
			} while (parse_packet(Data) != 0);
			xprintf("GPS signal OK\n");
			LCDp(L2, "---- READY -----");
		}
//		if (trackpoint%10 == 0) {
			res = f_sync(&File);
			if (res) {LCDp(L2, "ERROR - SD CARD"); return res;}
//		}
		x_axis = 0;
		amostras = 0;
	}

	/* Close file */
	f_close(&File);
	return 0;
}


int main (void)
{
	hardware_init();
	sys_init();
	sys_loop();

	/* SD card prompt*/
	FIO4CLR = LED3;
	do	{
		xputc('>');
		get_line(Line, sizeof(Line));
		comando(Line);
	} while(1);

	return 0;
}
